#### mysql面试题

###### mysql 中有哪些存储引擎

~~~
InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。
MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。
Merage是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库
archive 这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。
memory 类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。
~~~

###### mysql 数据库的逻辑架构

~~~~
第一层，即最上一层，所包含的服务并不是MySQL所独有的技术。它们都是服务于C/S程序或者是这些程序所需要的 ；连接处理，身份验证，安全性等等。
第二层值得关注。这是MySQL的核心部分。通常叫做 SQL Layer。在 MySQL据库系统处理底层数据之前的所有工作都是在这一层完成的，包括权限判断， sql解析，行计划优化， query cache 的处理以及所有内置的函数(如日期,时间,数学运算,加密)等等。各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视图等。
第三层包括了存储引擎。通常叫做StorEngine Layer ，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。就像Linux众多的文件系统 一样。每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎API来与它们交互的。这个接口隐藏 了各个存储引擎不同的地方。对于查询层尽可能的透明。这个API包含了很多底层的操作。如开始一个事 物，或者取出有特定主键的行。存储引擎不能解析SQL，互相之间也不能通信。仅仅是简单的响应服务器的请求。
~~~~

###### mysql索引结构

~~~
索引的数据结构和具体存储引擎的实现有关，在MySQL中使⽤较多的索引有Hash索引，B+树索引等， InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因 此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余⼤部分场景，建议选择BTree索引。 
    B+树：B+树是⼀个平衡的多叉树，从根节点到每个叶⼦节点的⾼度差值不超过1，⽽且同层级的节点间 有指针相互链接。在B+树上的常规检索，从根节点到叶⼦节点的搜索效率基本相当，不会出现⼤幅波 动，⽽且基于索引的顺序扫描时，也可以利⽤双向指针快速左右移动，效率⾮常⾼。因此，B+树索引被 ⼴泛应⽤于数据库、⽂件系统等场景。
    哈希索引：哈希索引就是采⽤⼀定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样 从根节点到叶⼦节点逐级查找，只需⼀次哈希算法即可⽴刻定位到相应的位置，速度⾮常快 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过⼀次算法即可找到相应的键值；前提 是键值都是唯⼀的。如果键值不是唯⼀的，就需要先找到该键所在位置，然后再根据链表往后扫描，直 到找到相应的数据； 如果是范围查询检索，这时候哈希索引就毫⽆⽤武之地了，因为原先是有序的键值，经过哈希算法后， 有可能变成不连续的了，就没办法再利⽤索引完成范围查询检索；哈希索引也没办法利⽤索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实 本质上也是范围查询）； 哈希索引也不⽀持多列联合索引的最左匹配规则； 
    B+树索引的关键字检索效率⽐较平均，不像B树那样波动幅度⼤，在有⼤量重复键值情况下，哈希索引 的效率也是极低的，因为存在哈希碰撞问题。
~~~

###### mysql B树和B+树的区别 为什么mysql使用B+树

~~~
mysql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问性能
    B树的特点： 1. 节点排序 2. ⼀个节点了可以存多个元素，多个元素也排序了
    B+树的特点： 1. 拥有B树的特点 2. 叶⼦节点之间有指针 3. ⾮叶⼦节点上的元素在叶⼦节点上都冗余了，也就是叶⼦节点中存储了所有的元素，并且排好顺序
Mysql索引使⽤的是B+树，因为索引是⽤来加快查询的，⽽B+树通过对数据进⾏排序所以是可以提⾼查 询速度的，然后通过⼀个节点中可以存储多个元素，从⽽可以使得B+树的⾼度不会太⾼，在Mysql中⼀ 个Innodb⻚就是⼀个B+树节点，⼀个Innodb⻚默认16kb，所以⼀般情况下⼀颗两层的B+树可以存2000 万⾏左右的数据，然后通过利⽤B+树叶⼦节点存储了所有数据并且进⾏了排序，并且叶⼦节点之间有指 针，可以很好的⽀持全表扫描，范围查找等SQL语句。
~~~

###### InnoDB和MyISAM的区别

~~~
MyISAM： 
不⽀持事务，但是每次查询都是原⼦的； 
⽀持表级锁，即每次操作是对整个表加锁；
存储表的总⾏数；
 ⼀个MYISAM表有三个⽂件：索引⽂件、表结构⽂件、数据⽂件； 采⽤⾮聚集索引，索引⽂件的数据域存储指向数据⽂件的指针。辅索引与主索引基本⼀致，但是辅 索引不⽤保证唯⼀性。 
InnoDb： 
⽀持ACID的事务，⽀持事务的四种隔离级别； 
⽀持⾏级锁及外键约束：因此可以⽀持写并发；
不存储总⾏数； 
⼀个InnoDb引擎存储在⼀个⽂件空间（共享表空间，表⼤⼩不受操作系统控制，⼀个表可能分布在 多个⽂件⾥），也有可能为多个（设置为独⽴表空，表⼤⼩受操作系统⽂件⼤⼩限制，⼀般为 2G），受操作系统⽂件⼤⼩的限制； 
主键索引采⽤聚集索引（索引的数据域存储数据⽂件本身），辅索引的数据域存储主键的值；因此 从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使⽤⾃增主键，防⽌插⼊ 数据时，为维持B+树结构，⽂件的⼤调整。
~~~

###### 事务的基本特性（ACID）

~~~
原子性：指的是一个事务的操作要么全部失败，要么全部成功
一致性：指的是数据库从一个一致性的状态转换到另外一个一致性的状态（如转账）
隔离性：指的是一个事务的修改在最终提交前，对其他事务是不可见的
持久性：指的是一旦事务提交，所做的修改就会永久保存到数据库中

隔离性有4个隔离级别，分别是：
    read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。 ⽤户本来应该读取到id=1的⽤户age应该是10，结果读取到了其他事务还没有提交的事务，结果读 取结果age=20，这就是脏读。 
    read commit 读已提交，两次读取结果不⼀致，叫做不可重复读。 不可重复读解决了脏读的问题，他只会读取已经提交的事务。 ⽤户开启事务读取id=1⽤户，查询到age=10，再次读取发现结果=20，在同⼀个事务⾥同⼀个查询 读取到不同的结果叫做不可重复读。 
    repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都⼀样，但是有可能产 ⽣幻读。 
    serializable 串⾏，⼀般是不会使⽤的，他会给每⼀⾏读取的数据加锁，会导致⼤量超时和锁竞争 的问题。
~~~

###### ACID靠什么保证

~~~
A原⼦性由undo log⽇志保证，它记录了需要回滚的⽇志信息，事务回滚时撤销已经执⾏成功的sql 
C⼀致性由其他三⼤特性保证、程序代码要保证业务上的⼀致性 
I隔离性由MVCC来保证 
D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可 以从redo log恢复
~~~

###### MySQL 包括的事务隔离级别如下

~~~
* 读未提交（READ UNCOMITTED）如果一个事务读取到了另一个未提交事务修改过的数据，那么这种隔离级别就称之为读未提交
* 读已提交（READ COMMITTED）如果一个事务只能读取到另一个已提交事务修改过的数据，并且其它事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种隔离级别就称之为读提交。
* 可重复读（REPEATABLE READ）在一些场景中，一个事务只能读取到另一个已提交事务修改过的数据，但是第一次读过某条记录后，即使其它事务修改了该记录的值并且提交，之后该事务再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种隔离级别就称之为可重复读。
* 串行化（SERIALIZABLE）如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。那么这种隔离级别就称之为串行化。
~~~

###### 事务并发可能引发什么呢问题

~~~
脏读：在事务A执行的过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据，由于某些原因事务A没有	完成提交，发生了回滚操作则事务B读取的数据就是脏数据 这种读取到另一个事务未提交的数据的现象就是脏读 
不可重复读：事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据	不一致。这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读
幻读：事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前	一次查询没有查询到的行。幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新

~~~

###### innodb是如何实现事务的

~~~
Innodb通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务，以⼀个update语句为例： 
    1. Innodb在收到⼀个update语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在Buffer Pool中 
    2. 执⾏update语句，修改Buffer Pool中的数据，也就是内存中的数据 
    3. 针对update语句⽣成⼀个RedoLog对象，并存⼊LogBuffer中 
    4. 针对update语句⽣成undolog⽇志，⽤于事务回滚 
    5. 如果事务提交，那么则把RedoLog对象进⾏持久化，后续还有其他机制将Buffer Pool中所修改的数 据⻚持久化到磁盘中 
    6. 如果事务回滚，则利⽤undolog⽇志进⾏回滚
~~~

###### 简单描述下mysql各种索引

~~~
主键索引：只有建立在主键上的索引被称为主键索引，一张表只能有一个主键缩影，索引列值不允许有空值
唯一索引：建立在唯一字段上的缩影被称为唯一缩影，一张表可以有多个唯一索引，索引列允许为空值，列值中出现多个空值不会发生重复冲突
普通索引：建立在普通字段上的索引被称为普通索引
联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。
前缀索引：前缀索引是指对字符串类型字段的前几个字符或者对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char，varchr，binary，varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。但是mysql无法使用前缀索引进行排序和分组

索引可以极⼤的提⾼数据的查询速度。
通过使⽤索引，可以在查询的过程中，使⽤优化隐藏器，提⾼系统的性能。 
但是会降低插⼊、删除、更新表的速度，因为在执⾏这些写操作时，还要操作索引⽂件 索引需要占物理空间，除了数据表占数据空间之外，每⼀个索引还要占⼀定的物理空间，如果要建⽴聚 簇索引，那么需要的空间就会更⼤，如果⾮聚集索引很多，⼀旦聚集索引改变，那么所有⾮聚集索引都 会跟着变。
~~~

###### 索引覆盖是什么

~~~
索引覆盖就是⼀个SQL在执⾏时，可以利⽤索引来快速查找，并且此SQL所要查询的字段在当前索引对 应的字段中都包含了，那么就表示此SQL⾛完索引后不⽤回表了，所需要的字段都在当前索引的叶⼦节 点上存在，可以直接作为结果返回了
~~~

###### 最左前缀原则是什么

~~~ 
 当⼀个SQL想要利⽤索引是，就⼀定要提供该索引所对应的字段中最左边的字段，也就是排在最前⾯的 字段，⽐如针对a,b,c三个字段建⽴了⼀个联合索引，那么在写⼀个sql时就⼀定要提供a字段的条件，这 样才能⽤到联合索引，这是由于在建⽴a,b,c三个字段的联合索引时，底层的B+树是按照a,b,c三个字段 从左往右去⽐较⼤⼩进⾏排序的，所以如果想要利⽤B+树进⾏快速查找也得符合这个规则
~~~

###### 什么是三星索引

~~~
对于一个查询而言，一个三星索引，可能是其最好的索引
    如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次窄索引片的扫描，因此其相应时间通常比使用一个普通索引的响应时间少几个数量级
    满足一星索引：如果where后面的等值条件列能够和某一个联合索引最前面的列一一匹配，甚至完全匹配，尽可能减少扫描的索引列宽度，这样就可以称为一星索引。
    满足二星索引：排除了排序操作，即把order by后面的列加入到索引中，保持列的顺序，这样就可以称为二星索引。
    满足三星索引：所要查询的全部列都已经包括在了索引当中，这样就可以称为三星索引。
    三星索引在实际业务中如果无法同时达到，一般我们认为第三颗星最重要，第一和第二颗星重要性差不多，根据业务情况调整这两颗星的优先度
~~~

###### 如何提交insert的性能

~~~
合并多条insert为一条  原因分析：主要原因是多条inert合并后日志量（binlog和innodb的事务日志）减少，降低日志刷盘的数据和频率，从而提高效率。通过合并sql语句，同时也能减少sql语句解析的次数，减少网络传输IO
修改参数bulk_insert_buff_size 调大批量插入的缓存 
设置innodb_flush_log_at_trx_commit=0
手动使用事
~~~

###### 什么是全局锁 共享锁 排它锁

~~~
全局锁就是对整个数据库实例加锁，它的经典使用场景就是做全库逻辑备份。这个命令可以使整个库处于只读状态。
    共享锁又称读锁（read lock）是读取操作创建的锁。其他用户可以并发读取数据，但是任何数据都不能对数据进行修改（获得数据上的排它锁），直到已释放所有的共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。
    排他锁（exclusive lock）又称写锁。若某个事务对某一行加上了排他锁，只能这个事务对其进行读写操作，在此事务结束之前，其他事务不能对其进行任何锁。其他进程可以读取，但不能进行写操作，需等待锁的释放。排他锁是悲观锁的一种实现。排他锁会阻塞所有的排他锁和共享锁    
~~~

###### 谈一下mysql中的死锁

~~~
死锁是指两个或者两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，他们都将无法进行下去。此时系统处于死锁状态或者系统产生了死锁。   
如何查看死锁？
    使用命令show engine innodb status 查看最近的一次死锁
    InnoDB Lock Monitor打开锁监控，每15s输出一次日志。使用完毕后建议关闭。否则会影响数据性能
对待死锁常见的两种策略
    通常innodblockwait_timeout来设置超时时间，一直等待知道超时；
    发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。
~~~

###### innoDB存储引擎锁的算法

~~~
Record lock：单个⾏记录上的锁
Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
Next-key lock：record+gap 锁定⼀个范围，包含记录本身

相关知识点： 
1. innodb对于⾏的查询使⽤next-key lock 
2. Next-locking keying为了解决Phantom Problem幻读问题 
3. 当查询的索引含有唯⼀属性时，将next-key lock降级为record key 
4. Gap锁设计的⽬的是为了阻⽌多个事务将记录插⼊到同⼀范围内，⽽这会导致幻读问题的产⽣ 
5. 有两种⽅式显式关闭gap锁：（除了外键约束和唯⼀性检查外，其余情况仅使⽤record lock） A. 将 事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1
~~~

###### 索引的基本原理

~~~
索引是用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。
索引的原理：就是把无序的数据变成有序的查询
1：把创建了索引的列的内容进行排序
2：对排序结果生成倒排表
3：在倒排表内容上拼上数据地址链
4：在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
~~~

###### mysql聚族索引和非聚族索引

~~~
都是B+树的数据结构
    聚簇索引：将数据存储与索引放到了⼀块、并且是按照⼀定的顺序组织的，找到索引也就找到了数 据，数据的物理存放顺序与索引顺序是⼀致的，即：只要索引是相邻的，那么对应的数据⼀定也是 相邻地存放在磁盘上的 
    ⾮聚簇索引：叶⼦节点不存储数据、存储的是数据⾏地址，也就是说根据索引查找到数据⾏的位置 再取磁盘查找数据，这个就有点类似⼀本树的⽬录，⽐如我们要找第三章第⼀节，那我们先在这个 ⽬录⾥⾯找，找到对应的⻚码后再去对应的⻚码看⽂章。
劣势：
 1、维护索引很昂贵，特别是插⼊新⾏或者主键被更新导⾄要分⻚(page split)的时候。建议在⼤量插⼊ 新⾏后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的⾏数据可能造成碎 ⽚。使⽤独享表空间可以弱化碎⽚
 2、表因为使⽤UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有⽐全表扫⾯ 更慢，所以建议使⽤int的auto_increment作为主键 
 3、如果主键⽐较⼤的话，那辅助索引将会变的更⼤，因为辅助索引的叶⼦存储的是主键值；过⻓的主 键值，会导致⾮叶⼦节点占⽤占⽤更多的物理空间 
 
InnoDB中⼀定有主键，主键⼀定是聚簇索引，不⼿动设置、则会使⽤unique索引，没有unique索引， 则会使⽤数据库内部的⼀个⾏的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引， 辅助索引访问数据总是需要⼆次查找，⾮聚簇索引都是辅助索引，像复合索引、前缀索引、唯⼀索引， 辅助索引叶⼦节点存储的不再是⾏的物理位置，⽽是主键值 MyISM使⽤的是⾮聚簇索引，没有聚簇索引，⾮聚簇索引的两棵B+树看上去没什么不同，节点的结构完 全⼀致只是存储的内容不同⽽已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。 表数据存储在独⽴的地⽅，这两颗B+树的叶⼦节点都使⽤⼀个地址指向真正的表数据，对于表数据来 说，这两个键没有任何差别。由于索引树是独⽴的，通过辅助键检索⽆需访问主键的索引树。 
如果涉及到⼤数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占 空间⼩，这些操作是需要在内存中完成的
~~~

###### Mysql慢查询该如何优化？

~~~
1. 检查是否⾛了索引，如果没有则优化SQL利⽤索引 
2. 检查所利⽤的索引，是否是最优索引 
3. 检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据 
4. 检查表中数据是否过多，是否应该进⾏分库分表了 
5. 检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源
~~~

###### 什么是MVCC

~~~
多版本并发控制：读取数据是通过一种类似快照的方式将数据保存下来。这样读锁和写锁不冲突了，不同的事务session会看到自己特定版本的数据——版本链
    MVCC只在读已提交（rc）和可重复du（rr）两个隔离级别下工作，其他两个隔离级别和MVCC不兼容，因为读未提交 总是读取的是最新的数据行，而不是符合当前事务版本的数据行。而串行化则会对所有读取的行加锁
    聚族索引记录中有两个必要的隐藏列：
trx_id:用来存储妹子对某条聚镞索引记录进行修改的时候的事务ID
Roll_pointer:每次对哪条聚镞索引记录有修改的时候，都会把老版本的写入undo日志中。这个roll_pointer就是存了一个指针，它指向这个条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。（插入操作的undo日志没有这个属性，因为他没有老版本）
开始事务时创建readview，readview维护当前活动得事务ID,即未提交的事务ID，排列生成一个数组，访问数据，获取数据中的是事务ID(获取的是事务ID最大记录)，对比readview
    如果readview的左边（比readview都小），可以访问（意味着改事务已经提交）
    如果readview的右边（比readview都大）或者就在readview中，不可以访问，获取roll_pointer，取上一个版本重新对比（在右边意味着，该事物在readview生成之后出现，在readview中意味着该事务还未提交）
    已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的Readview，而可重复读隔离级别则在第一次读的时候生成一个Readview，之后的读都是复用之前的Readview
    这就是mysql的MVCC 通过版本链，实现多版本，可并发读-写，写-读 通过Readview生成策略的不同实现不同的隔离级别
~~~

###### Mysql主从同步原理

~~~
mysql主从同步的过程： 
Mysql的主从复制中主要有三个线程： master（binlog dump thread）、slave（I/O thread 、SQL thread） ，Master⼀条线 程和Slave中的两条线程。 
    主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务 器启动的那⼀刻起，保存所有修改数据库结构或内容的⼀个⽂件。 
    主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。 
    从节点 I/O线程接收 binlog 内容，并将其写⼊到 relay log ⽂件中。 
    从节点的SQL 线程读取 relay log ⽂件内容对数据更新进⾏重放，最终保证主从数据库的⼀致性。 
注：主从节点使⽤ binglog ⽂件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的 偏移量，如果从节点发⽣宕机重启，则会⾃动从 position 的位置发起同步。 

由于mysql默认的复制⽅式是异步的，主库把⽇志发送给从库后不关⼼从库是否已经处理，这样会产⽣ ⼀个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，⽇志就丢失了。由此产⽣两个 概念。 
        全同步复制 
主库写⼊binlog后强制同步⽇志到从库，所有的从库都执⾏完成后才返回给客户端，但是很显然这个⽅ 式的话性能会受到严重影响。 
        半同步复制 
和全同步不同的是，半同步复制的逻辑是这样，从库写⼊⽇志成功后返回ACK确认给主库，主库收到⾄ 少⼀个从库的确认就认为写操作完成。
~~~



##### Redis面试题