##### Redis面试题

###### 什么是缓存雪崩、击穿、穿透？

~~~
缓存雪崩：通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。那么，当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题
缓存击穿：我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。
缓存穿透：当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。
~~~

###### 缓存雪崩、击穿、穿透应对办法？

~~~
缓存雪崩：
第一种方案，均匀设置过期时间:如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，给这些数据的过期时间加上一个随机数，这样就保证数据不会在同一时间过期。
第二种方案，互斥锁:当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。
第三种方案，双 key 策略:我们对缓存数据可以使用两个 key，一个是主 key，会设置过期时间，一个是备 key，不会设置过期，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，同时更新「主 key 」和「备 key 」的数据
第四种，后台更新缓存
第五种，Redis的高可用
第六种,限流降级
缓存击穿：
第一种方案，互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
第二种方案，不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；
缓存传穿透
第一种方案，非法请求的限制；
第二种方案，缓存空值或者默认值；
第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；
~~~


###### redis的持久化

~~~
Redis支持两种方式的持久化，一种是RDB方式、另一种是AOF（append-only-file）方式，两种持久化方式可以单独使用其中一种，也可以将这两种方式结
合使用。redis默认采用的是RDB的方式。

RDB：根据指定的规则“定时”将内存中的数据存储在硬盘上，生成的快照
    •save #由Redis主进程来执行RDB，会阻塞所有命令，Redis停机时会执行
    •bgsave 开启子进程执行RDB,避免主进程受到影响（for-read-write），一次会执行一次RDB也可以在配置文件中配置
    缺点：RDB执行间隔时间长，两次RDB之间写入数据有数据丢失的风险，fork子进程、压缩、写出RDB文件都比较耗时
•AOF：每次执行命令后将命令本身记录下来，每次执行命令都会将命令写入到aof文件中
      AOF可以配置三种刷盘策略：appendfsync always：每次执行写命令都会刷盘，非常慢，也非常安全。
                            appendfsync everysec：每秒刷盘一次，兼顾性能和安全。
                            appendfsync no：将刷盘操作交给系统，很快，不安全。
      因为appendonly.aof文件中存储的是执行命令，所以会产生很多没用的命令，因此，redis会定期根据最新的内存数据生成新的aof文件。AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多
影响
~~~
###### redis主从同步
~~~
redis主从数据同步可以分为全量同步和部分同步。
每个redis启动时都会生成一个随机字符串RID（replication ID ），从节点怎么判断需要同步多少呢？
通过偏移量offset来确定。主节点每次有数据写入，都会在offset上加上写入的字节长度，所以从节点通过比较RID和offset就能确定需要同步多少数据。

部分同步：
1.从节点保存的主节点RID与主节点的RID一致时，从节点非第一次同步，通过offset把这部分需要同步的数据放入缓冲区，然后异步同步到从节点。

全量同步：
1.当从节点第一次启动，进行数据同步时，是全量同步的。
2.当从节点保存的主节点RID与主节点的RID不一致时，说明主节点可能宕机或重启过啥的，数据已经不一致了，所以需要重新全量同步，同时删除掉旧的数据。
3.当部分同步需要同步的数据超过了缓存区的大小限制时，采用全量同步。

注意：RDB和AOF的复制可以同时进行的。
~~~